# Operating System Lab 3

<div style="text-align: right"> 운영체제(SW) 2분반, 32170578, 김산 </div>

## [ Lab 3 EXT2 file system 실습]

### File System layout analysis
---
#### 1) 모듈 적재후 확인
![image](https://user-images.githubusercontent.com/28651727/118755773-74e14600-b8a4-11eb-854e-4e3631a2ea08.png)

#### 2) 파일시스템 포멧후 ./mnt에 마운트

![image](https://user-images.githubusercontent.com/28651727/118755843-993d2280-b8a4-11eb-89cb-962ebf1409b9.png)

#### 3) ./create.sh 실행
![image](https://user-images.githubusercontent.com/28651727/118755968-de615480-b8a4-11eb-8449-45fb13cf9d8e.png)

create.sh스크립트를 수행한후 0~9번 디렉토리가 생성된것을 확인하였습니다. 
제 학번은 32170578이므로 ls -l mnt/5/78에 apd를 통해 블럭을 추가하여 파일크기가 49160이 된것을 확인하였습니다. 

---
### 1. Root Directory에서 찾을 File이 속한 Directory의 Inode Number찾기

#### Super Block 영역 분석
첫번째 Group Descriptor Table은 램디스크의 1블록 이후부터 시작하므로 xxd명령어를 통해 0x1000(16^3B = 4KB) 부터 256byte를 읽었습니다. 
![image](https://user-images.githubusercontent.com/28651727/118394712-40da0b00-b681-11eb-952e-ee0687d84d8a.png)

- inode count : 0x8000
- block count : 0x20000
- log block size : 0x2
- blocks per group : 0x8000
- inodes per group : 0x2000
- block group number : 0x0

#### Group Descriptor Table 영역 분석
![image](https://user-images.githubusercontent.com/28651727/118758540-32226c80-b8aa-11eb-8d12-363e500ebb76.png)

- Block bitmap : 0x21 블록부터 시작
- Inode bitmap : 0x22 블록부터 시작
- Inode table  : 0x23 블록부터 시작

Ext2에서 Root inode number는 2번이고, inodes per group의 값은 0x2000이므로
- root's block group : (2-1) / 0x2000 = 0
- root's index : (2-1) % 0x2000 = 1
- root는 0번 Block Group의 Inode Table의 1번째(index=1)에 위치한다

#### Inode Table 영역 분석

![image](https://user-images.githubusercontent.com/28651727/118765153-9dbe0700-b8b5-11eb-8a5d-cd1bbfbcf8c8.png)

Inode의 크기는 0x100 byte 이고, Root가 속한 Block Group은 0, Index는 1이므로 0번 Block Group의 Inode Table 0x100 부터 Root Inode이다.

![image](https://user-images.githubusercontent.com/28651727/118766399-559fe400-b8b7-11eb-9824-830262109afc.png)

- mode : 0x41ed = 0100000 111 101 101 = d rwx r-x r-x
- block pointer : 0x223

#### Data 영역 분석

![image](https://user-images.githubusercontent.com/28651727/118768270-c34d0f80-b8b9-11eb-994b-165633c7fcc9.png)

- 5번 Directory
  - inode number : 0x6066
  - file type : 0x2 = directory

![image](https://user-images.githubusercontent.com/28651727/118774497-dca58a00-b8c0-11eb-9a5f-b5b669db59ea.png)

stat명령어를 통해 분석을 통해 얻은 5번디렉토리의 inode number와 file type이 일치하는지 확인하였습니다.  
0x6066은 10진수로 24678이므로 일치합니다.

- 속한 Block Group : (0x6066 – 1) / 0x2000 = 3번 Block Group
- Inode Table Index : (0x6066 – 1) % 0x2000 = 65
- 5번 디렉터리의 Inode는 3번 Block Group의 Inode Table에서 65번째(index=65)에 위치함을 알 수 있습니다.

### 2. Diretory가 속한 Block Group의 Inode Table에서 디렉토리의 Inode찾기

Inode의 크기는 0x100 byte 이고, 5번 디렉터리가 속한 Block Group은 3, Index는 65이므로 3번 Block Group의 Inode Table 0x6500 부터 5번 디렉터리의 inode임을 알 수 있습니다.

![image](https://user-images.githubusercontent.com/28651727/118908445-6eaea080-b95c-11eb-96ea-8d70c40f3202.png)

Group Descriptor Table 영역을 분석하여 3번 Block Group의 Inode table의 시작부분이 0x18023임을 알 수 있습니다.

inode table의 65번째 인덱스의 inode번호는 0x18023000 + 0x6500 = 0x18029500입니다.  
따라서 0x18029500에 해당하는 위치를 xxd를 통해 조회하면 다음과 같습니다. 

![image](https://user-images.githubusercontent.com/28651727/118909008-5428f700-b95d-11eb-887d-7041b797a927.png)

- mode : 0x41ed = 0100000 111 101 101 = d rwx r-x r-x
- block pointer : 0x10207
5번 디렉토리의 inode가 가리키고있는 data block은 0x10207번 입니다.

### 3. 찾은 Directory Entry에서 File의 Inode Number찾기

각 블럭의 크기는 0x1000(4Kbyte)이므로 0x10207에 0x1000을 곱한 값을 통해 5번 디렉토리의 데이터 블럭을 조회합니다.

![image](https://user-images.githubusercontent.com/28651727/118909836-8ab34180-b95e-11eb-8c75-2d54f08d06fc.png)

![image](https://user-images.githubusercontent.com/28651727/118910685-e3370e80-b95f-11eb-81fe-b264b9d26280.png)

data영역을 조회하면 78번 파일의 inode number가 60b5임을 확인할 수 있습니다. 

해당 inode를 분석하면
- 속한 Block Group : (0x60b5 – 1) / 0x2000 = 3번 Block Group
- Inode Table Index : (0x60b5 – 1) % 0x2000 = b4

inode table의 b4번 인덱스의 inode번호는 0x18023000 + 0xb400 = 0x1802E400입니다.  
따라서 0x18029500에 해당하는 위치를 xxd를 통해 조회하면 다음과 같습니다. 

![image](https://user-images.githubusercontent.com/28651727/118947202-14303700-b992-11eb-9c46-36905ec86b86.png)


78번 파일의 inode가 가리키고있는 데이터블럭이 0x10642, 0x10842, 0x10E60 임을 알 수 있습니다.  
이를 통해 각 데이터 블럭을 조회하면 다음과 같이 파일의 블록을 확인할 수 있습니다. 

![image](https://user-images.githubusercontent.com/28651727/118947483-56597880-b992-11eb-9af2-115d44805655.png)

![image](https://user-images.githubusercontent.com/28651727/118947495-5a859600-b992-11eb-8892-b9e86b57bea6.png)

![image](https://user-images.githubusercontent.com/28651727/118947522-62453a80-b992-11eb-9035-1d6a6916879a.png)

## [EXT2 file system 실습 Bouns]

![image](https://user-images.githubusercontent.com/28651727/118961028-d685db00-b99e-11eb-8b44-79a7490019eb.png)

vim /mount

![image](https://user-images.githubusercontent.com/28651727/118961775-a985f800-b99f-11eb-9874-fd9d8727f789.png)


## Discussion

PPT를 따라하면서 막혔던 곳이 3번 Block Group을 찾을때였습니다.  
처음에는 5번 디렉토리의 inode를 확인하고 0x6066이므로 3번 Blcok Group을 찾기위해서 0번 그룹의 inode table에 Block Group의 size만큼 더해주면 될거라 생각을 했습니다. 0x23000에 group당 block의 개수가 0x8000이므로 blcok의 size(0x1000)을 곱하여 0번그룹의 inode table위치를 더하면 1번 그룹의 inode table을 찾을 수 있을 것이라 생각을 했는데 이상한 값들이 나와서 당황했습니다.

그래서 Ext2 File system내용을 다시 찾아보면서 Group Descriptor Table 영역에 다른 그룹들의 정보가 들어있을것이라는 생각이 들었고 Group Descriptor Table 그림을 참고하면서 다음 그룹들의 inode table위치를 확인할 수 있었습니다. 

![image](https://user-images.githubusercontent.com/28651727/118963743-b99ed700-b9a1-11eb-8b1c-24cd354ec1bb.png)

3번 그룹의 inode table의 위치를 확인한 후 파일까지 찾아가는 과정은 수월했습니다.

평소에 자주 사용하던 탐색기를 통해 기존의 파일을 열람하는것은 이미 상당히 추상화 되어 있기 때문에 파일시스템에 대한 이해가 필요 없었습니다. 하지만 이번 Lab3과제를 진행하면서 파일시스템(특히 Ext2 파일시스템)의 구조가 어떻게 이루어져 있는지 조금더 구체적으로 확인할 수 있었고, 힘들여 삽질하는 시간이 있었던 만큼 Ext2파일시스템의 구조와 원리에 대해 조금더 오래 기억할 수 있을것 같습니다. 

Bonus과제에서는 단순히 모듈을 수정하는 과정이었지만 어떤 함수를 수정해야할지 찾는 과정에서 파일시스템 생성 모듈이 어떻게 코드로 구현되어있는지 접할 수 있었습니다. 함수들이 사용용도와 목적에 맞는 이름들을 가지고 있었고 인자의 순서도 어떤 정해진 위치에 따라 정갈하게 구현되어있는것이 제가 앞으로 어떻게 코딩을 해 나가야 할 지 방향점을 시사하고 있는것 같았습니다. 

이번 과제를 하면서 코딩을 따로 하는 부분은 없었지만 리눅스 파일 시스템의 내부구조를 직접 눈으로 확인하고 삽질하면서 좀더 오래 기억할 수 있을 것 같고, 특히나 제가보았던 모듈의 코드부분은 자주 참고하게 될 것 같습니다. 

추가적으로 커널 모듈을 다루는 과정에 흥미를 느껴서 간단한 모듈을 생성하고 적재해 보았습니다. 

```c
#include <linux/init.h>
#include <linux/module.h>
MODULE_LICENSE("Dual BSD/GPL"); /* optional */

static int __init hello_init(void)
{
            printk(KERN_NOTICE "Hello, World #2\n");
                return 0; /* return zero on successful loading */
}

static void __exit hello_exit(void)
{
            printk(KERN_NOTICE "Goodbye\n");
}

module_init(hello_init);
module_exit(hello_exit);
```
위와 같은 코드를 통해 모듈을 작성하고, dmesg명령어를 통해 모듈 동작을 확인하였습니다. 

![image](https://user-images.githubusercontent.com/28651727/119068226-b4cc3880-ba1e-11eb-872b-b4b26372b007.png)