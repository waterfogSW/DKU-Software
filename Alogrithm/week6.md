# 6주차

## 성능측정
- 퀵 정렬과 합병 정렬의 성능 비교를 위해 모두 순환 알고리즘을 사용
- 퀵 정렬에서 분할 원소는 중간값 규칙을 사용하였다. 
  - 중간값 규칙 : a[m], a[(m+p-1)/2], a[p-1] 중의 중간 값

### 레포트 2

- 퀵정렬 중간값 규칙 사용

## 2.5 선택

- 리스트와 k가 주어질 때 k번재 작은 원소를 결정하여 k위치에 두며, k위치 앞에는 a[j]보다 작거나 같은 원소들이, k위치 뒤에는 a[j]보다 크거나 같은 원소들이 오도록 재매치

- 퀵정렬에서 사용된 분할 사용, 
  - P1 : a[1], a[2], ... ,a[j-1]
  - P2 : a[j]
  - P3 : a[j+1], ..., a[n] 으로 된다.
  - j == k이면 멈추고 k < j이면 P1, k > j 이면 P2를 사용

```java
void Select1(int a[], int n, int k) {
    int low = 1, up = n+1;
    a[n+1] = Integer.MAX_VALUE;
    do {
        int j = Partition(a, low, up);
        if(k == j) return;
        else if (k < j) up = j;
        else low = j + 1;
    } while (true);
}
```

### 시간 분석

- Partition 함수는 O(p-m)시간이 필요하다. 선택 알고리즘에서 최악의 경우 Partition이 n번 호출될 수 있다.(k가 1일때)
  - 퀵 정렬의 최악의 경우와 일치

### 최악의 경우 최적 알고리즘
- 중간 값들의 중간 값 규칙을 사용
- 최악의 경우 복잡도 O(n)을 갖게 된다.

### 2.6 Strassen의 행렬 곱셈
- 분할-정복 기법을 사용한 행렬 곱셈

## 4장 욕심쟁이 방법

- 가능해 : 주어진 제약조건을 만족하는 해
- 최적해 : 가능해 중 주어진 목적함수를 최소 또는 최대로 하는 해
- 부분집합형
  - 한번에 한개의 입력을 고려, 제약 조건 만족시 해의 집합에 포함, 그렇지 않으면 버림
```java
SolType Greedy(type a[], int n) {
    SolType solution = EMPTY;
    for(int i = 1; i < = n; i++) {
    Type x= Selection(a);
    if Feasible(solution, x)
        solution = Union(solution, x);
    }
}
```

- 순서형 : 특정한 순서로 입력을 고려
  - 최적 평가 기준을 사용하여 결정한다
```java
SolType Greedy(type a[], int n) {
    SolType solution = EMPTY;
    for(int i = 1; i < = n; i++) {
        Type x = Selection(a);
        solution = Union(solution, x);
    }
}
```

### 4.1 최소비용 신장 트리

- 최소의 비용을 갖는 신장 트리
  - 비용 : 신장 트리에 포함된 간선들의 비용
- 제한조건
  - 1. 그래프 내의 간선들만을 사용
  - 2. n-1개의 간선만을 포함
  - 3. 사이클을 포함하지 않는다.
- 가능해 : 모든 신장트리
- 최적해 : 비용이 가장 적은 신장트리

### 욕심쟁이 전략
- 간선들을 하나씩 처리함으로써 트리를 구성한다. 특정 최적화 기준에 따라 선택된다.
- Kruskal의 알고리즘
  - 그래프의 간선들을 비용의 오름차수능로 차례차례고려, 사이클을 형성하지 않을때 포함시킨다.
- Prim의 알고리즘
  - 지금까지 포함된 간선들의 비용의 합을 최소로 증가시키는 간선을 선택
  - 간선들의 부분집합으로 해를 만드므로 부분 집합형

#### Kruskal의 알고리즘
- 한번에 하나씩 비용이 가장 작은 간선을 선택하여 T에 이미 포함된 간선들과 사이클을 형성하지 않는 간선들만을 차례로 T에 추가.
- 알고리즘
```c++
while((T가 n-1개 미만의 간선을 포함) && (E가 공백이 아님)) {
    E에서 최소 비용 간선 (v,w) 선택;
    E에서 (v,w)를 삭제;
    if((v,w)가 T에서 사이클을 형성하지 않음) T에 (v,w)를 추가;
    else (v,w)를 거부;
}
if(T가 n-1개 미만의 간선을 포함) cout << "신장트리 없음" << endl;
```
- 시간 복잡도 : O(e log e)

#### Prim의 알고리즘
- 트리 T에 인접한 간선들 중 T와 사이클을 형성하지 않는 최소비용 간선 (u,v)를 구해 T에 추가한다
- 알고리즘
```c++
TV = {1}; //정점 1로 시작, 간선은 비어있음
for (T=Φ; T의 간선수가 n-1보다 적을때; (u,v)를 T에 추가) {
    u 가 TV에 속하고, v가 TV에 속하지 않는 최소비용간선(u,v);
    if(그런 간선이 없다) break;
    v를 TV에 추가
}
```
- 시간복잡도 : O(n<sup>2</sup>)
