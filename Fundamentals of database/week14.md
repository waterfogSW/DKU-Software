## 트랜잭션
- 하나의 작업을 수행하는데 필요한 데이터베이스 연산들을 모아놓은것
- 작업 수행에 필요한  SQL문들의 모임
- 논리적인 작업의 단위
- 복구작업, 병행제어 작업을 위해 중요한 단위

### 트랜잭션의 특성(ACID 특성)
원자성
- 트랜잭션의 연산들이 모두 정상적으로 실행, 또는 하나도 실행되지 않아야 함
- 트랜잭션중 장애발생 -> 원래상태로 회복
- 원자성의 보장을 위해 장애발생 시 회복 기능이 필요

일관성
- 트랜잭션이 성공적으로 수행된 후에도 데이터베이스가 일관된 상태를 유지해야한다
  
격리성
- 수행중인 트랜잭션이 완료될 때까지 다른 트랜잭션들이 중간 연산 결과에 접근할 수 없다
- 격리성 보장을 위해 여러 트랜잭션이 동시에 수행되더라도 마치 순서대로 하나씩 수행되는것 처럼 정확하고 일관된 결과를 얻도록 제어해야함
- 격리성으로 인해 성능저하가 발생할 수 있다

지속성
- 트랜잭션이 성공적으로 완료된 후 데이터베이스에 반영한 수행결과는 영구적이어야한다
- 장애발생시 회복기능이 필요

### 트랜잭션의 연산
commit 연산
- 트랜잭션이 성공적으로 수행되었음을 선언(작업 완료)

rollback 연산
- 트랜잭션을 수행하는데 실패했음을 선언(작업 취소)

### 트랜잭션의 상태
활동 - 부분완료 - 완료  
활동 - 부분환료 - 실패 - 철회

## 장애와 회복
장애
- 시스템이 제대로 동작하지 않는 상태 

트랜잭션 장애
- 의미 : 트랜잭션 수행중 오류가 발생하여 정상적 수행을 할수 없는 상태
- 원인 : 트랜잭션의 논리적 오류, 잘못된 데이터 입력, 자원의 과다사용 요구, 처리 대상 데이터의 부재

시스템 장애
- 의미 : 하드웨어의 결함으로 정상적으로 수행을 계속할 수 없는 상태
- 원인 : 하드웨어 이상으로 메인 메모리에 저장된 정보 손실, 교착상태 발생

미디어 장애
- 의미 : 디스크 장치의 결함으로 인해 데이터베이스 일부 혹은 전체가 손상된 상태
- 원인 : 디스크 헤드의 손상이나 고장

트랜잭션의 수행을 위해 필요한 데이터 이동 연산
- input / output : 디스크 <-> 메인메모리
- read / write : 메인메모리 <-> 프로그램 변수

이동연산의 필요성
- 데이터 베이스는 디스크에 상주
- 트랜잭션은 데이터베이스의 데이터를 처리하기 위해 디스크데이터를 메인메모리로 가져과 처리후 디스크로 보내는 작업이 필요

블록단위 수행
- 디스크 블록 : 디스크에 있는 블록
- 버퍼 블록 : 메인메모리 블록

회복(recovery)
- 장애가 발생했을 때 데이터베이스를 장애가 발생하기 전의 일관된 상태로 복구시키는 것
- 트랜잭션의 특성을 보장하고, 데이터베이스를 일관된 상태로 유지하기 위해 필수적인 기능
- 회복 관리자(recovery manager)가 담당
  - 장애 발생을 탐지하고, 장애가 탐지되면 데이터베이스 복구 기능을 제공

회복을 위해 복사본을 만들기
- dump : 주기적으로 데이터 베이스 전체를 다른 저장 장치에 복사
- log : 변겨연산 시 데이터 변경 이전값, 이후 값을 별도의 파일에 기록

### 회복기법
로그회복기법
- 즉시 갱신 회복 기법
  - 트랜잭션 수행 중 데이터 변경 연산의 결과를 데이터베이스에 즉시 반영
  - 데이터 변경 내용을 로그파일에 기록
    - 트랜잭션 완료전 장애 발생 -> redo
    - 트랜잭션 완료후 장애 발생 -> undo
  - 지연 갱신 회복 기법
  - 트랜잭션 수행 중에 데이터 변경 연산의 결과를 로그에만 기록해두고,트랜잭션이 부분 완료된 후에 로그에 기록된 내용을 이용해 데이터베 이스에 한번에 반영
    - 트랜잭션 완료전 장애 발생 -> 로그내용을 무시하고 버림
    - 트랜잭션 완료후 장애 발생 -> redo

검사시점 회복기법
- 로그 기록을 이용하되 일정 시간 간격으로 검사 시점(check point)를 만듦
- 장애 발생 시 가장 최근 검사 시점 이후의 트랜잭션에만 회복 작업 수행
- 로그 전체를 대상으로 회복 기법을 적용할 때 발생할 수 있는 비효율성의 문제를 해결

미디어 회복기법
- 덤프 이용, 일정 주기마다 다른 안전한 저장 장치에 복사
- 디스크 장에 발생시 덤프를 이용해 복구, 필요에 따라 redo연산 수행


### 병행제어

병행수행
- 여러 트랜잭션을 동시에 수행하는 것을 의미
- 트랜잭션을 번갈아 수행되는 **인터리빙** 방식으로 진행됨

병행제어, 동시성 제어
- 병행수행시 같은 데이터에 접근하여 연산을 실행해도 문제가 발생하지 않고 정확한 수행 결과를 얻을 수 있도록 트랜잭션의 수행을 제어하는것을 의미

#### 문제점
갱신분실
- 하나의 트랜잭션이 수행한 데이터 변경 연산의 결과를 다른 트랜잭션이 덮어써 변경 연산이 무효화되는것

모순성
- 하나의 트랜잭션이 여러 개 데이터 변경연산 실행시 일괁성 없는 상태의 데이터 베이스에서 데이터를 가져와 연산

연쇄 복귀
- 트랜잭션이 완료되기 전 장애가 발생하여 rollback연산을 수행하면, 장애 발생 전에 이 트랜잭션이 변경한 데이터를 가져가서 변경연산을 실행한 다른 트랜잭션에도 rollback연산을 연쇄적으로 실행해야 하는데 이미 완료되어 rollback을 할 수 없는경우

### 트랜잭션 스케줄
직렬 스케줄
- 인터리빙을 이용하지 않고 순차적으로 실행
  - 모순이 없는 정확한 결과
  - 병행수행 X

비직렬 스케줄
- 인터리빙 방식을 이용하여 병행하여 수행
  - 트랜잭션을 번갈아 수행, 완료전 다른 연산이 실행될 수 있다
  - 결과의 정확성 보장 X
  - 다양한 비직렬 스케줄 가능

직렬 가능 스케줄
- 직렬 스케줄과 같이 정확한 결과를 생성하는 비직렬 스케줄
  - 인터리빙 방식으로 병행수행하면서도 정확한 결과를 얻을 수 있다. 
  - (직렬 가능성을 판단하기 힘듬) -> 병행제어 기법을 사용하여 직렬 가능성을 보장하는것이 일반적

### 병행제어 기법
- 병행수행 하면서도 직렬 가능성을 보장

Locking기법
- 먼저 접근한 데이터에 대한 연산을 끝낼때 까지는 다른 트랜잭션이 데이터에 접근하지 못하도록 상호배제
- lock : 데이터에 대한 독점권 요청
- unlock : 트랜잭션이 데이터에대한 독점권을 반환

Lock단위 
- 단위 증가 $\rarr$ 병행성 $\darr$, 제어 병행성 $\uarr$
- 단위 감소 $\rarr$ 병행성 $\uarr$, 제어 병행성 $\darr$

#### Lock의 효율성을 높이기 위한 방법
공용 shared lock 
- 데이터에 대한 read연산만 실행할 수 있다.
- 데이터에 다른 트랜잭션도 공용 lock연산을 동시에 실행할 수 있다.

전용 sxclusive lock
- 데이터에 대한 read,write연산 모두 가능하다.
- 다른 트랜잭션은 공용이든 전용이든 어떤 lock연산도 실행할 수 없다.

#### 2단계 로킹 규약
확장단계 
- 트랜잭션이 lock연산만 실행할 수 있고, unlock 연산은 실행할 수 없는 단계

축소단계
- 트랜잭션이 unlock연산만 실행할 수 있고, lock 연산은 실행할 수 없는 단계

교착상태
- 트랜잭션들이 상대가 독점하고 있는 데이터에 unlock연산이 실행되기를 서로 기다리면서 트랜잭션의 수행을 중단하고 있는 상태
